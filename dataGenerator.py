import numpy as np
import pandas as pd


class ParityDataGenerator:
    def __init__(self, digit=4):
        """
        ParityDataGenerator
        generator of the required parity data with input data with the same dimensionality as self.digit
        and corresponding output label, which is 1 when input attributes have odd 1s and 0 else
        :param digit: the digit of input data
        """
        self.digit = digit
        self.max_generated_value = np.power(2, self.digit)

    def generate_data(self):
        """
        generate parity data correspond to digit
        
        :return: pandas.DataFrame object which contains the target data
        """
        attributes = self.generate_attributes()
        labels = np.array([self.generate_labels(attributes)])
        columns = ['digit%d' % (i + 1) for i in range(self.digit)]
        columns.append('label')
        data = np.concatenate([attributes, labels.T], axis=1)
        _df = pd.DataFrame(data, columns=columns)
        return _df

    def generate_attributes(self):
        """
        generate data entry
        :return:
        """
        result = []
        for i in range(self.max_generated_value):
            binary = np.binary_repr(i, self.digit)
            result.append([int(char) for char in binary])
        return np.array(result)

    def generate_labels(self, attributes):
        result = attributes.sum(axis=1, dtype=np.int32)

        return np.remainder(result, 2)


def h_func(x):
    temp = np.sin(2 * np.pi * x)
    return 0.4 * temp + 0.5


class FuncDataGenerator:
    def __init__(self, base_func=h_func, x_shape=1, y_shape=1):
        """
        Generator of o=paired training data based on given function, noise can be added to the generated data
        :param base_func: generator function, should take np.array input and output np.array, with corresponding dimension
        :param x_shape: the dimensionality of attribute
        :param y_shape: the dimensionality of label
        """
        self.base_func = base_func
        self.x_shape = [x_shape]
        self.y_shape = [y_shape]

    def generate_data(self, random_method_attribute='uniform', x_range=(0.0, 1.0),
                      random_method_noise='uniform', noise_range=(-0.1, 0.1),
                      num_data=100):
        """
        Method for generating data
        :param random_method_attribute: method for generate xs, could be uniform
        :param x_range: range of attributes generated by the generator, tuple of float
        :param random_method_noise: method for noise added to the 'label' or desired output, could be either None or
        uniform. None stands for no noise added
        :param noise_range: range of the noise added, None or a tuple. if None noise added this field is ignored
        :param num_data: number of data generated
        :return: pandas.DataFrame, with column name of attributes as attributes%d and labels as desired%d
        """
        xs = self.generate_attributes(random_method_attribute=random_method_attribute, x_range=x_range,
                                      num_data=num_data)
        ys = self.generate_labels(xs, random_method_noise=random_method_noise, noise_range=noise_range)
        columns = ['attribute%d' % (i + 1) for i in range(self.x_shape[0])]
        columns_ = ['desired%d' % (i + 1) for i in range(self.y_shape[0])]
        columns = columns + columns_
        data = np.concatenate([xs, ys],axis=1)
        _df = pd.DataFrame(data, columns=columns)
        return _df

    def generate_attributes(self, random_method_attribute, x_range, num_data):
        size = np.array([num_data])
        size = np.concatenate([size, self.x_shape])
        return np.random.uniform(low=x_range[0], high=x_range[1], size=size)

    def generate_labels(self, xs, random_method_noise, noise_range):
        num_data = xs.shape[0]
        result = []
        for i in range(num_data):
            temp = self.base_func(xs[i, :])
            noise = np.zeros(self.y_shape)
            if random_method_noise == 'uniform':
                noise = np.random.uniform(low=noise_range[0], high=noise_range[1], size=self.y_shape)
            result.append(temp + noise)
        return np.array(result)
